{"version":3,"file":"bundle.js","sources":["node_modules\\browserify\\node_modules\\browser-pack\\_prelude.js","index.js","node_modules\\debounce\\index.js","node_modules\\path-to-regexp\\index.js","node_modules\\debounce\\node_modules\\date-now\\index.js"],"names":["escape","str","replace","hide","selector","elements","document","querySelectorAll","i","length","style","display","show","update","keys","regexp","pathRegexp","_","value","textContent","toString","innerHTML","map","key","name","optional","join","updatePath","path","test","result","exec","require","debounce","querySelector","bind","addEventListener","now","module","exports","func","wait","immediate","later","last","timestamp","timeout","setTimeout","apply","context","args","this","arguments","callNow","escapeGroup","group","pathtoRegexp","options","Array","isArray","strict","end","flags","sensitive","index","RegExp","groups","source","match","push","delimiter","repeat","attachKeys","PATH_REGEXP","escaped","prefix","capture","suffix","endsWithSlash","slice","re","Date","getTime"],"mappings":"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","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","'use strict';\r\n\r\nvar pathRegexp = require('path-to-regexp');\r\nvar debounce = require('debounce');\r\n\r\nvar _ = document.querySelector.bind(document);\r\n\r\nfunction escape(str) {\r\n  return str.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/\\\"/g, '&quot;');\r\n}\r\nfunction hide(selector) {\r\n  var elements = document.querySelectorAll(selector);\r\n  for (var i = 0; i < elements.length; i++) {\r\n    elements[i].style.display = 'none';\r\n  }\r\n}\r\nfunction show(selector) {\r\n  var elements = document.querySelectorAll(selector);\r\n  for (var i = 0; i < elements.length; i++) {\r\n    elements[i].style.display = null;\r\n  }\r\n}\r\n\r\n_('#inputRoute').addEventListener('input', debounce(update, 100), false);\r\n_('#inputPath').addEventListener('input', debounce(updatePath, 100), false);\r\n\r\nvar keys, regexp;\r\nfunction update() {\r\n  keys = [];\r\n  regexp = pathRegexp(_('#inputRoute').value, keys);\r\n  _('#regexp-display').textContent = regexp.toString();\r\n  if (keys.length) {\r\n    _('#keys-display').innerHTML = '<ol>' + keys.map(function wrap(key) {\r\n      return '<li>' + escape(key.name) + (key.optional ? ' (optional)' : '') + '</li>';\r\n    }).join('') + '</ol>';\r\n  } else {\r\n    _('#keys-display').innerHTML = 'There are no keys captured by this route';\r\n  }\r\n  updatePath();\r\n}\r\nfunction updatePath() {\r\n  var path = _('#inputPath').value;\r\n  if (regexp.test(path)) {\r\n    hide('.is-not-match');\r\n    show('.is-match');\r\n    var result = regexp.exec(path);\r\n    _('#keys-results-display').innerHTML = '<dl class=\"dl-horizontal\">' + keys.map(function (key, i) {\r\n      return '<dt>' + escape(key.name) + '</dt><dd>' +\r\n      escape(result[i + 1]) + '</dd>';\r\n    }).join('') + '</dl>';\r\n  } else {\r\n    show('.is-not-match');\r\n    hide('.is-match');\r\n  }\r\n}\r\nupdate();\r\n","\n/**\n * Module dependencies.\n */\n\nvar now = require('date-now');\n\n/**\n * Returns a function, that, as long as it continues to be invoked, will not\n * be triggered. The function will be called after it stops being called for\n * N milliseconds. If `immediate` is passed, trigger the function on the\n * leading edge, instead of the trailing.\n *\n * @source underscore.js\n * @see http://unscriptable.com/2009/03/20/debouncing-javascript-methods/\n * @param {Function} function to wrap\n * @param {Number} timeout in ms (`100`)\n * @param {Boolean} whether to execute at the beginning (`false`)\n * @api public\n */\n\nmodule.exports = function debounce(func, wait, immediate){\n  var timeout, args, context, timestamp, result;\n  if (null == wait) wait = 100;\n\n  function later() {\n    var last = now() - timestamp;\n\n    if (last < wait && last > 0) {\n      timeout = setTimeout(later, wait - last);\n    } else {\n      timeout = null;\n      if (!immediate) {\n        result = func.apply(context, args);\n        if (!timeout) context = args = null;\n      }\n    }\n  };\n\n  return function debounced() {\n    context = this;\n    args = arguments;\n    timestamp = now();\n    var callNow = immediate && !timeout;\n    if (!timeout) timeout = setTimeout(later, wait);\n    if (callNow) {\n      result = func.apply(context, args);\n      context = args = null;\n    }\n\n    return result;\n  };\n};\n","/**\n * Expose `pathtoRegexp`.\n */\nmodule.exports = pathtoRegexp;\n\n/**\n * The main path matching regexp utility.\n *\n * @type {RegExp}\n */\nvar PATH_REGEXP = new RegExp([\n  // Match already escaped characters that would otherwise incorrectly appear\n  // in future matches. This allows the user to escape special characters that\n  // shouldn't be transformed.\n  '(\\\\\\\\.)',\n  // Match Express-style parameters and un-named parameters with a prefix\n  // and optional suffixes. Matches appear as:\n  //\n  // \"/:test(\\\\d+)?\" => [\"/\", \"test\", \"\\d+\", undefined, \"?\"]\n  // \"/route(\\\\d+)\" => [undefined, undefined, undefined, \"\\d+\", undefined]\n  '([\\\\/.])?(?:\\\\:(\\\\w+)(?:\\\\(((?:\\\\\\\\.|[^)])*)\\\\))?|\\\\(((?:\\\\\\\\.|[^)])*)\\\\))([+*?])?',\n  // Match regexp special characters that should always be escaped.\n  '([.+*?=^!:${}()[\\\\]|\\\\/])'\n].join('|'), 'g');\n\n/**\n * Escape the capturing group by escaping special characters and meaning.\n *\n * @param  {String} group\n * @return {String}\n */\nfunction escapeGroup (group) {\n  return group.replace(/([=!:$\\/()])/g, '\\\\$1');\n}\n\n/**\n * Attach the keys as a property of the regexp.\n *\n * @param  {RegExp} re\n * @param  {Array}  keys\n * @return {RegExp}\n */\nvar attachKeys = function (re, keys) {\n  re.keys = keys;\n\n  return re;\n};\n\n/**\n * Normalize the given path string, returning a regular expression.\n *\n * An empty array should be passed in, which will contain the placeholder key\n * names. For example `/user/:id` will then contain `[\"id\"]`.\n *\n * @param  {(String|RegExp|Array)} path\n * @param  {Array}                 keys\n * @param  {Object}                options\n * @return {RegExp}\n */\nfunction pathtoRegexp (path, keys, options) {\n  if (keys && !Array.isArray(keys)) {\n    options = keys;\n    keys = null;\n  }\n\n  keys = keys || [];\n  options = options || {};\n\n  var strict = options.strict;\n  var end = options.end !== false;\n  var flags = options.sensitive ? '' : 'i';\n  var index = 0;\n\n  if (path instanceof RegExp) {\n    // Match all capturing groups of a regexp.\n    var groups = path.source.match(/\\((?!\\?)/g) || [];\n\n    // Map all the matches to their numeric keys and push into the keys.\n    keys.push.apply(keys, groups.map(function (match, index) {\n      return {\n        name:      index,\n        delimiter: null,\n        optional:  false,\n        repeat:    false\n      };\n    }));\n\n    // Return the source back to the user.\n    return attachKeys(path, keys);\n  }\n\n  if (Array.isArray(path)) {\n    // Map array parts into regexps and return their source. We also pass\n    // the same keys and options instance into every generation to get\n    // consistent matching groups before we join the sources together.\n    path = path.map(function (value) {\n      return pathtoRegexp(value, keys, options).source;\n    });\n\n    // Generate a new regexp instance by joining all the parts together.\n    return attachKeys(new RegExp('(?:' + path.join('|') + ')', flags), keys);\n  }\n\n  // Alter the path string into a usable regexp.\n  path = path.replace(PATH_REGEXP, function (match, escaped, prefix, key, capture, group, suffix, escape) {\n    // Avoiding re-escaping escaped characters.\n    if (escaped) {\n      return escaped;\n    }\n\n    // Escape regexp special characters.\n    if (escape) {\n      return '\\\\' + escape;\n    }\n\n    var repeat   = suffix === '+' || suffix === '*';\n    var optional = suffix === '?' || suffix === '*';\n\n    keys.push({\n      name:      key || index++,\n      delimiter: prefix || '/',\n      optional:  optional,\n      repeat:    repeat\n    });\n\n    // Escape the prefix character.\n    prefix = prefix ? '\\\\' + prefix : '';\n\n    // Match using the custom capturing group, or fallback to capturing\n    // everything up to the next slash (or next period if the param was\n    // prefixed with a period).\n    capture = escapeGroup(capture || group || '[^' + (prefix || '\\\\/') + ']+?');\n\n    // Allow parameters to be repeated more than once.\n    if (repeat) {\n      capture = capture + '(?:' + prefix + capture + ')*';\n    }\n\n    // Allow a parameter to be optional.\n    if (optional) {\n      return '(?:' + prefix + '(' + capture + '))?';\n    }\n\n    // Basic parameter support.\n    return prefix + '(' + capture + ')';\n  });\n\n  // Check whether the path ends in a slash as it alters some match behaviour.\n  var endsWithSlash = path[path.length - 1] === '/';\n\n  // In non-strict mode we allow an optional trailing slash in the match. If\n  // the path to match already ended with a slash, we need to remove it for\n  // consistency. The slash is only valid at the very end of a path match, not\n  // anywhere in the middle. This is important for non-ending mode, otherwise\n  // \"/test/\" will match \"/test//route\".\n  if (!strict) {\n    path = (endsWithSlash ? path.slice(0, -2) : path) + '(?:\\\\/(?=$))?';\n  }\n\n  // In non-ending mode, we need prompt the capturing groups to match as much\n  // as possible by using a positive lookahead for the end or next path segment.\n  if (!end) {\n    path += strict && endsWithSlash ? '' : '(?=\\\\/|$)';\n  }\n\n  return attachKeys(new RegExp('^' + path + (end ? '$' : ''), flags), keys);\n};\n","module.exports = Date.now || now\n\nfunction now() {\n    return new Date().getTime()\n}\n"]}